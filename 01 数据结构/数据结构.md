[TOC]

## 1 数据结构

### 1.1 数据基本概念

​	数据是信息的载体，是计算机处理对象的集合。
​	数据元素也称为节点，是组成数据的基本单位。（学生的成绩）
​	数据项是数据的最小单位。是数据的的最小元素，具有原子性，不可分割。（学号、性别等）
​	数据对象是具有相同数据元素的子集，是数据的子集。（学生的语文成绩）
​	数据结构是计算机存储、组织数据的方式，描述了数据元素的相互关系和组织形式。

### 1.2 数据结构基本概念

​	逻辑结构：从逻辑关系上描述数据，与数据存储无关，独立于语言。

​	存储结构：指数据元素及其关系在计算机存储时如何表示，依赖于语言。

### 1.3 算法概念

​	算法：为求解一个问题需要遵循的被清晰地指定的简单指令的集合。

​	复杂度：是衡量一个算法好坏的重要手段，分为时间复杂度和空间复杂度。

​	时间复杂度：一个算法执行时间长短来衡量算法的优劣。如果问题规模问n，则时间复杂度为n的一个函数，T(n)=O(f(n))。

​	空间复杂度：一个算法执行过程中所要占用的存储空间多少来衡量一个算法的优劣，则空间复杂度问题规模为n的一个函数，S(n)=O(f(n))。

​	算法的执行时间=算法循环次数*操作执行的时间

​	复杂度越高，算法执行效率越低，算法也越差。

## 2 存储结构

### 2.1 线性结构：指有且仅有一个开始节点和一个终端节点，所有节点都最多只有一个直接前驱和一个直接后继。

![1539164709290](/assets/4.png)

#### 2.1.1 线性表

概念：线性表是最基本、最简单、也是最常用的一种数据结构。 主要有顺序结构与链式结构。

#### 2.1.2 栈

概念： 是一种限制只能再某一端进行插入和删除操作的线性表，遵循后进先出的规则。

![1539228962861](/assets/2.png)

Java中使用Stack来操作栈数据，常用方法：push、pop、peek、empty、search、size等方法

##### 顺序栈-----栈的顺序结构

特点：

 - 数据元素存放在连续的存储地址中。
- 栈底位置固定不变。
- 栈顶位置随出栈、进栈操作而变化。

##### 链栈-----栈的链式结构

链式栈可以通过单链表的方式来实现，使用链式栈的优点在于它能够克服用数组实现的顺序栈空间利用率不高的特点，但是需要为每个栈元素分配额外的指针空间用来存放指针域。 

#### 2.1.3 队列

概念：是允许在一端进行插入，在另一端进行删除的运算受限的线性表，遵循先进先出的规则。

![1539230094987](/assets/1.png)

Java中使用**Queue**来操作栈数据，常用方法：add、remove、element、offer、poll、peek、put、take等方法

##### 顺序队列

特点：

- 顺序操作存储空间，是用一组地址连续的存储空间来存储队列。
- 只能从队头删除元素，从队尾添加元素。
- 队列为空时，front=rear。
- 队列为满时，rear=队列长度-1。
- 队列非空非满时，front<rear<队列长度-1。

##### 链式队列

特点：

- 动态分配存储空间
- 只能从队头删除元素，从队尾添加元素。
- 链式队列在入队时没有队满问题。
- 队列为空的条件：front=rear。

### 2.2 非线性结构：指一个节点可能有多个直接前驱和直接后继。

![1539164779703](/assets/3.png)

#### 2.2.1 树

##### 2.2.1.1 概念

- 树：是指由n个节点组成的有限集合。

- 空树：n=0时，称为空树。
- 根：树的顶端节点称为树的根。
- 子树：除根之外，其余节点可以分为若干个互不相交的子集，每个子集又是一颗树，称为树的子树。
- 度数：在树之中，所有节点的最大度数为树的度数。
- 层数：在树之中，根节点的层数为0，其他节点的层数为父节点的层数+1。节点的层数反映该节点在树中的位置。
- 边：树中各节点之间的连线称为边。
- 路径：从一个节点移动到另一个节点，所经过的节点顺序称为路径。
- 高：树的根节点到树中叶节点最长路径称为树的高。
- 有序树：M叉树中所有节点的度数最大为M，二叉树中每个节点的度数均不超过2。
- 森林：指n个互不相交的树的集合。
- 满二叉树：二叉树的高度为H（H>=0）且有2^(H+1)-1个节点，则为满二叉树。
- 完全二叉树：满二叉树从右向左删除叶子节点之后的二叉树，为完全二叉树。

![1539327094931](/assets/1539327094931.png)

- A有2颗子树，A的度数为2。
- D/E/F/H/I度数为0，被称为叶子节点。
- 最大度数为B的度数，因此树的度数为3。
- 满二叉树一定是完全二叉树，而完全二叉树不一定是满二叉树。

##### 2.2.1.2 特点

- SUM(节点数量)=SUM(节点的度数)+1
- 二叉树中在第i层上，最多有2^n个节点
- 如果一个二叉树叶节点数量为n0，度为2的节点数量为n2，则n0=n2+1。
- 高度为H（H>=0）的二叉树最多有2^(H+1)-1个节点。
- 具有n个节点的完全二叉树的深度为|_Log2N_|+1 

##### 2.2.1.3 存储结构

- 顺序存储
  - 只适用于满二叉树和完全二叉树。因为对于其他二叉树会产生不同程度的资源浪费。可以通过补充空节点来组成完全二叉树。

  ![1539331370787](/assets/1539331370787.png)

  - 如果完全二叉树的第i个节点存储在数组的第i个元素中，则父节点存储在i/2（直接去掉小数位数取整）的位置，左孩子在2i的位置，右孩子为2i+1的位置。

- 链式存储

  - 在链式存储中，每个节点的结构如下 

  ![img](https://images2015.cnblogs.com/blog/991470/201611/991470-20161113210244202-520338226.png) 

  - 利用指针域我们便可以完美的存储非完全二叉树 

  ![1539331542299](/assets/1539331542299.png)

  

##### 2.2.1.4 树的遍历

​	二叉树的遍历指以某种次序访问二叉树中所有节点，并且使每个节点恰好只访问一次。

- 先序遍历

  - 访问根节点
  - 访问左子树
  - 访问右子树

  ![1539334288437](/assets/1539334288437.png)

  ABDEC

- 中序遍历

  - 中序访问左子树
  - 访问根节点
  - 中序访问右子树

  ![1539334402517](/assets/1539334402517.png)

  DBEAC

- 后序遍历

  - 访问根节点
  - 后序访问左子树
  - 后序访问右子树

  ![1539334574938](/assets/1539334574938.png)

  DEBCA

#### 2.2.2 图

##### 2.2.2.1 概念

​	是由非空的顶点集合和一个描述顶点之间相互关系（边）的有限集合组成，图可以用二元组定义为：G=(V,E)，G表示图，V表示图中顶点的集合，E表示图中边的集合。

​	(V1,V2)为图中的边。

![1539335307744](/assets/1539335307744.png)

​	路径上边的数量成为路径的长度。在一个图中，如果任意2个顶点都是连通的，那么这个图就是连通图。

​	在图定义的基础上，然后将每个边加上一定的权重，这就构成了带权图。 

##### 2.2.2.2 图的存储结构

- 邻接矩阵：用来表示图中顶点之间的邻接关系。

  ![1539338194602](/assets/1539338194602.png)![1539338203491](/assets/1539338203491.png)

  ![1539338331656](/assets/1539338331656.png)

- 邻接表

  ![1539338194602](/assets/1539338194602.png)

  ![1539338231463](/assets/1539338231463.png)

- 十字链表

  ![1539855019006](/assets/1539855019006.png)

- 邻接多重表

![1539855034732](/assets/1539855034732.png)

##### 2.2.2.2 图的遍历

从图的某个顶点出发，按照某种方法对图中的所有其他顶点进行访问，且使每个顶点仅被访问一次。

- 深度优先搜索(ABCFGDHIJ)

  ![1539856090557](/assets/1539856090557.png)

- 广度优先搜索(ABCDEFGHIJ)

![1539856251165](/assets/1539856251165.png)



### 2.3 递归

概念：在定义自身的过程中又直接或间接调用自身的一种算法。

要素：递归调用、递归终止条件

特点：

- 一个问题可以被分解为若干简单的子问题。
- 子问题和其上层问题的解决方案一致。
- 外层问题的解决依赖于子问题的解决。

例子：n的阶乘、斐波那契数列（Fibonacci）:F(n)=F(n-1)+F(n-2)

### 2.4 哈希表

#### 2.4.1 概念

​	在数据的存储位置和数据的关键字之间建立一个确定的对应关系，使得每个关键字和结构中的一个唯一存储位置对应，对应关系则为哈希函数，建立的表为哈希表。也叫散列表，是根据关键码值而直接进行访问的数据结构。

#### 2.4.2 选择方法

​	简单、均匀。

#### 2.4.3 常用方法：直接寻址法、数字分析法、平方取中法、叠加法、除留余数法。

- 直接寻址法：h(k)=a*key+b（a、b为正整数）
- 数字分析法：取关键字中某些取值较分散的数字位作为哈希地址。关键字需确定。
- 平方取中法：取关键字平方的中间几位作为哈希地址。
- 叠加法：首先将哈希表中关键字分割成位数相等的几段，然后将他们叠加求和作为哈希地址。关键字位数多，哈希地址位数少，每位关键字分散都比较集中。
- 除留余数法：h(k)=key%p（p为正整数，小于又接近哈希表的长度）

#### 2.4.4 冲突

两个不同的键，由于哈希方法返回的值相同，因而呗映射到表的同一位置上。

- 解决方法

  - 开放寻址法

    按照某种方法继续探测哈希表中的其他存储单元，直到找到空位置位置。根据探测步长的不同，开房寻址法分为线性探测和二次探测等。

    h(key,i)=h(h(key)+i^n)%m(i=0,1,2......m-1，m为哈希表的长度，i为寻址的步长，当n=1时为线性寻址)

  - 再哈希法

    指在用哈希方法计算哈希地址时，准备两个以上的哈希方法。当前一个哈希方法发生冲突时，继续用下一个计算哈希地址，直到没有冲突为止。

  - 链地址法

    把映射到同一地址的所有元素（即冲突元素）放在一个链表中，哈希表中的相应位置只保存一个指向这个链表头结点的指针。

#### 2.4.5 哈希查找

## 3 排序

### 3.1 分类

- 非线性时间比较类排序
  - 交换排序
    - 冒泡排序
    - 快速排序
  - 插入排序
    - 简单插入排序
    - 希尔排序
  - 选择排序
    - 简单选择排序
    - 堆排序
  - 归并排序
    - 二路归并排序
    - 多路归并排序
- 线性时间非比较类排序
  - 计数排序
  - 桶排序
  - 基数排序

![1539916885791](/assets/1539916885791.png)

### 3.2 冒泡排序

![img](/assets/849589-20171015223238449-2146169197.gif) 

步骤：

- 比较相邻的元素。如果第一个比第二个大，就交换它们两个；
- 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；
- 针对所有的元素重复以上的步骤，除了最后一个；
- 重复步骤1~3，直到排序完成。

### 3.3 选择排序

![img](/assets/849589-20171015224719590-1433219824.gif) 

步骤：

- 初始状态：无序区为R[1..n]，有序区为空；
- 第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；
- n-1趟结束，数组有序化了。

### 3.4 插入排序

![img](/assets/849589-20171015225645277-1151100000.gif) 

步骤：

- 从第一个元素开始，该元素可以认为已经被排序；
- 取出下一个元素，在已经排序的元素序列中从后向前扫描；
- 如果该元素（已排序）大于新元素，将该元素移到下一位置；
- 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；
- 将新元素插入到该位置后；
- 重复步骤2~5。

### 3.5 希尔排序

![img](/assets/849589-20180331170017421-364506073.gif) 

步骤：

- 选择一个增量序列t1，t2，…，tk，其中ti>tj，tk=1；
- 按增量序列个数k，对序列进行k 趟排序；
- 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。

### 3.6 归并排序

![img](/assets/849589-20171015230557043-37375010.gif) 

步骤：

- 把长度为n的输入序列分成两个长度为n/2的子序列；
- 对这两个子序列分别采用归并排序；
- 将两个排序好的子序列合并成一个最终的排序序列。

### 3.7 快速排序

![img](/assets/849589-20171015230936371-1413523412.gif) 

步骤：

- 从数列中挑出一个元素，称为 “基准”（pivot）；
- 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
- 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。

### 3.8 堆排序

![img](/assets/849589-20171015231308699-356134237.gif) 

步骤：

- 将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；
- 将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]<=R[n]；
- 由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。

### 3.9 计数排序

![img](/assets/849589-20171015231740840-6968181.gif) 

步骤：

- 找出待排序的数组中最大和最小的元素；
- 统计数组中每个值为i的元素出现的次数，存入数组C的第i项；
- 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；
- 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。

### 3.10 桶排序

![1539917686415](/assets/1539917686415.png)

步骤：

- 设置一个定量的数组当作空桶；
- 遍历输入数据，并且把数据一个一个放到对应的桶里去；
- 对每个不是空的桶进行排序；
- 从不是空的桶里把排好序的数据拼接起来。

### 3.11 基数排序

![img](/assets/849589-20171015232453668-1397662527.gif) 

步骤：

- 取得数组中的最大数，并取得位数；
- arr为原始数组，从最低位开始取每个位组成radix数组；
- 对radix进行计数排序（利用计数排序适用于小范围数的特点）；