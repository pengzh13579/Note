
[TOC]

### 1 Java 基础

#### 1.1 JDK、JRE、JVM 分别是什么？有什么区别？
​        JDK（Java Development Kit）是针对Java开发员的产品，是整个Java的核心，包括了Java运行环境JRE、Java工具和Java基础类库。Java Runtime Environment（JRE）是运行JAVA程序所必须的环境的集合，包含JVM标准实现及Java核心类库。JVM是Java Virtual Machine（Java虚拟机）的缩写，是整个java实现跨平台的最核心的部分，能够运行以Java语言写作的软件程序。
![TIM截图20190612093424](/assets/TIM截图20190612093424.png)
#### 1.2 == 和 equals 的区别是什么？
- ==是判断两个变量或实例是不是指向同一个内存空间，equals是判断两个变量或实例所指向的内存空间的值是不是相同 
- ==是指对内存地址进行比较 ， equals()是对字符串的内容进行比较
- ==指引用是否相同， equals()指的是值是否相同
#### 1.3 两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？
​        类的hashCode方法和equals方法都可以重写，返回的值完全在于自己定义。hashCode()返回该对象的哈希码值；equals()返回两个对象是否相等。
- 两个对象equals()比较返回true，那么两个对象的hashCode()方法必须返回相同的结果。
- 两个对象equals()比较返回false，不要求hashCode()方法也一定返回不同的值，但是最好返回不同值，以提高哈希表性能，因为equals()方法比较的就是对象在内存中的值，如果值相同，那么HashCode值也应该相同。但是如果不重写hashcode方法，就会出现不相等的情况。。
- 重写equals()方法，必须重写hashCode()方法，以保证equals方法相等时两个对象hashcode返回相同的值。
#### 1.4 final 在 java 中有什么作用？
- 用于修饰类、类属性和类方法。
- 被final关键字修饰的类不能被继承。
- 被final关键字修饰的类属性和类方法不能被覆盖（重写）。
- 对于被final关键字修饰的类属性而言，子类就不能给他重新赋值了，如果重新赋值，会报错。
#### 1.5 java 中的 Math.round(-1.5) 等于多少？
​        将括号内的数+0.5之后，向下取值。
​        round(3.4)就是3.4+0.5=3.9，向下取值是3，所以round(3.4)=3; 
​        round(-10.5)就是-10.5+0.5=-10，向下取值就是-10，所以round(-10.5)=-10
​        Math.round(-1.5) = -1
#### 1.6 String 属于基础的数据类型吗？
​        String不是基本的数据类型，是final修饰的java类。
java中的基本类型一共有8个，它们分别为：
- 字符类型：byte，char
- 基本整型：short，int，long
- 浮点型：float，double
- 布尔类型：boolean
#### 1.7 java 中操作字符串都有哪些类？它们之间有什么区别？
- String : final修饰，String类的方法都是返回new String。即对String对象的任何改变都不影响到原对象，对字符串的修改操作都会生成新的对象。
- StringBuffer : 对字符串的操作的方法都加了synchronized，保证线程安全。
- StringBuilder : 不保证线程安全，在方法体内需要进行字符串的修改操作，可以new StringBuilder对象，调用StringBuilder对象的append、replace、delete等方法修改字符串。
#### 1.8 String str1="str"与 String str2=new String("str")一样吗？
- String str1 = “str”：
 - 在栈中创建str1的引用。
 - 去常量池中查看是否有相同Unicode编码的字符串常量。如果有将str1指向该常量，如果没有则创建一个内容为”str”的字符串常量，将str1的引用指向该常量。
 - 如果str1进行了赋值str1= “123”,则栈中的str1的引用指向新的内容为“123”的字符串常量。
 - String str1 = “str”; String str2 = “str”;str2的引用指向常量池中已经存在的内容为“str1”的常量，不会重新创建新的常量，str1和str2的引用指向同一个常量。
`str1 == str2; str1+”a” != str2+”a”;`
- String str1 = new String(“str1”)：
 - 在常量池中创建内容为“str”的对象，在堆中创建内容为“str”的对象。
 - String str1 = new String(“str”); String str2 = new String(“str”);str2不会指向之前创建的对象，而是重新创建一个对象。
`str1 != str2;`
#### 1.9 如何将字符串反转？
```
// 方法一
String s = "abcdefg";
String s2 = "";
char[] cs = s.toCharArray();
for(int i = cs.length-1; i >= 0; i--) {
	s2 = s2 + cs[i];
}
System.out.println("对字符串进行反转操作后为:" + s2);
// 方法二
StringBuffer sb = new StringBuffer("abcdefg");
StringBuffer sb2 = sb.reverse();
System.out.println("对StringBuffer进行反转操作后为:" + sb2);
```
#### 1.10 String 类的常用方法都有那些？
##### 1.10.1 转换成String方法
1.10.1.1 public String();
​        空参构造 初始化一个新创建的 String 对象，使其表示一个空字符序列

1.10.1.2 public String(byte[] bytes);
​        通过使用平台的默认字符集解码指定的 byte 数组，构造一个新的 String
​        将97,97.99转成ascll码表对应的字符;

1.10.1.3 public String(byte[] bytes,int index,int length);
​        分配一个新的 String，使其表示字符数组参数中当前包含的字符序列。
​        将99,100.101.转成ascll码表对应的字符

1.10.1.4 public String(char[] value)
​        分配一个新的 String，使其表示字符数组参数中当前包含的字符序列。
​        输出abcde;

1.10.1.5 public String(char[] value,int index,int count);
​        分配一个新的 String，它包含取自字符数组参数一个子数组的字符。
​        将字符数组从某个下标开始,转多少个

1.10.1.6 public String(String original)
​        初始化一个新创建的 String 对象，使其表示一个与参数相同的字符序列；换句话说，新创建的字符串是该参数字符串的副本。
​        将String类型的字符串转换成字符串,一般也不用

##### 1.10.2 判断方法
1.10.2.1 boolean equals(Object obj);
​        将此字符串与指定的对象比较。当且仅当该参数不为 null，并且是与此对象表示相同字符序列的 String 对象时，结果才为 true。

1.10.2.2 boolean equalsIgnoreCase(String str);
​        将此 String 与另一个 String 比较，不考虑大小写。如果两个字符串的长度相同，并且其中的相应字符都相等（忽略大小写），则认为这两个字符串是相等的。
​        这两个例子的比较都为true;

1.10.2.3 boolean contains(String str);
​        当且仅当此字符串包含指定的 字符串 值序列时，返回 true。
​        第一个返回true,第二个返回false;

1.10.2.4 boolean startsWith(String str);
​        判断是否以某个字符串开头
​        第一个返回为ture,第二个返回为false;

1.10.2.5 boolean endsWith(String str);
​        判断是否以某个字符串结尾结束。
​        第一个返回为false,第二个返回为true;

1.10.2.6 boolean isEmpty();
​        当且仅当 length() 为 0 时返回 true
​        “”和null的区别:
​        “”是字符串常量.同时也是一个String类的对象,既然是对象当然可以调用String类中的方法;
​        Null是空常量,不能调用任何的方法,否则会出现空指针异常,null常量可以给任意的引用数据类型赋值
##### 1.10.3 String类中的获取方法
1.10.3.1 int length();
​        返回此字符串的长度。
​        数组中的length是属性,String类中的length()是方法。

1.10.3.2 Char charAt(int index);
​        返回指定索引处的 char 值。索引范围为从 0 到 length() - 1。序列的第一个 char 值位于索引 0 处，第二个位于索引 1 处，依此类推，这类似于数组索引。

1.10.3.3 int indexof(int ch);
​        返回指定字符在此字符串中第一次出现处的索引

1.10.3.4 int indexof(String str);
​        返回指定子字符串在此字符串中第一次出现处的索引。

1.10.3.5 int indexof(int ch,int fromIndex );
​        返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索

1.10.3.6 int indexof(String str,int fromIndex);
​        返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始

1.10.3.7 lastIndexof;
- lastIndexOf(int ch)
​        返回指定字符在此字符串中最后一次出现处的索引。
- lastIndexOf(int ch, int fromIndex)
​        返回指定字符在此字符串中最后一次出现处的索引，从指定的索引处开始进行反向搜索。
- lastIndexOf(String str) 
​        返回指定子字符串在此字符串中最右边出现处的索引。
- lastIndexOf(String str, int fromIndex) 
​        返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索。

1.10.3.8 String substring(int start);
​        从指定位置开始截取字符串,默认都末尾;

1.10.3.9 substring(int beginIndex, int endIndex)
从指定位置开始到指定位置截取字符串,包含头,不包含尾;

##### 1.10.4 String类的转换功能
1.10.4.1 byte[] getBytes();
​        使用指定的字符集将此 String 编码为 byte 序列，并将结果存储到一 个新的 byte 数组中。

1.10.4.2 char[] toCharArray();
​        将此字符串转换为一个新的字符数组。

1.10.4.3 static String valueOf(char[] date);
​        把字符数组转换成字符串;

1.10.4.4 static String valueOf(int i);
​        把int类型的数据转换成字符串。
​        注意：String类的valueOf方法可以把任意类型的数据转成字符串。

##### 1.10.5 String类的其他方法
1.10.5.1 String rerplace(char old,char new);
​        返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。

1.10.5.2 String replace(String old,String new);
​        返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。

1.10.5.3 String trim();
​        去掉字符串两端的空格

1.10.5.4 int compareTo(String anotherString)
​        按字典顺序比较两个字符串。该比较基于字符串中各个字符的 Unicode 值。按字典顺序将此 String 对象表示的字符序列与参数字符串所表示的字符序列进行比较。如果按字典顺序此 String 对象位于参数字符串之前，则比较结果为一个负整数。如果按字典顺序此 String 对象位于参数字符串之后，则比较结果为一个正整数。如果这两个字符串相等，则结果为 0；

1.10.5.5 int compareToIgnoreCase(String str) 
​        按字典顺序比较两个字符串，不考虑大小写。此方法返回一个整数，其符号与使用规范化的字符串调用 compareTo 所得符号相同，规范化字符串的大小写差异已通过对每个字符调用 ​        ​        ​        ​        Character.toLowerCase(Character.toUpperCase(character)) 消除。

#### 1.11 抽象类必须要有抽象方法吗？
​        抽象类可以没有抽象方法，但是如果你的一个类已经声明成了抽象类，即使这个类中没有抽象方法，它也不能再实例化，即不能直接构造一个该类的对象。如果一个类中有了一个抽象方法，那么这个类必须声明为抽象类，否则编译通不过。
#### 1.12 普通类和抽象类有哪些区别？
- 抽象类不能被实例化；
- 抽象类可以有构造函数，被继承时子类必须继承父类一个构造方法，抽象方法不能被声明为静态。抽象类的构造函数用来初始化抽象类的一些字段，而这一切都在抽象类的派生类实例化之前发生。不仅如此，抽线类的构造函数还有一种巧妙应用：就是在其内部实现子类必须执行的代码；
- 抽象方法只需申明，而无需实现，抽象类中可以允许普通方法有主体；
- 含有抽象方法的类必须申明为抽象类；
- 抽象的子类必须实现抽象类中所有抽象方法，否则这个子类也是抽象类。
#### 1.13 抽象类能使用 final、private修饰吗？
- 抽象类需要被继承才能使用，而被final修饰的类无法被继承，所以abstract和final是不能共存的。
- 抽象类是内部类时，所以abstract和private是能共存，如果是非内部类，则不能共存。
#### 1.14 接口和抽象类有什么区别？
- 抽象类可以有构造方法，接口中不能有构造方法。
- 抽象类中可以有普通成员变量，接口中没有普通成员变量。
- 抽象类中可以包含非抽象普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的方法。
- 抽象类中的抽象方法的访问权限可以是 public、protected 和(默认类型，虽然 eclipse 不报错，但也不能用，默认类型子类不能继承)，接口中的抽象方法只能是 public 类型的，并且默认即为 public abstract 类型。
- 抽象类中可以包含静态方法，在 JDK1.8 之前接口中不能不包含静态方法，JDK1.8 以后可以包含。
- 抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问权限可以是任意的，但接口中定义的变量只能是 public static final 类型的，并且默认即为 public static final 类型。
- 一个类可以实现多个接口，用逗号隔开，但只能继承一个抽象类，接口不可以实现接口，但可以继承接口，并且可以继承多个接口，用逗号隔开。
#### 1.15 java 中 IO 流分为几种？
![TIM截图20190612093424](/assets/0964a7fbd139787cd6c64ffb74c97793.jpg)
#### 1.16 BIO、NIO、AIO 有什么区别？
​        同步阻塞的BIO、同步非阻塞的NIO、异步非阻塞的AIO
#### 1.17 Files的常用方法都有哪些？
- Files.exists() 检测文件路径是否存在
- Files.createFile()创建文件
- Files.cteateDirectory()创建文件夹
- Files.delete() 删除文件或者目录
- Files.copy() 复制文件
- Files.move() 移动文件
- Files.size（）查看文件个数
- Files.read() 读取文件
- Files.write()写入文件
### 2 容器

#### 2.1 java 容器都有哪些？
|Collection 
|　　├List 有序、元素可重复
|　　│-├LinkedList 允许null元素、可被用作堆栈（stack），队列（queue）或双向队列（deque）。
|　　│-├ArrayList 可变大小的数组、允许所有元素、不同步
|　　│-└Vector 同步的
|　　│　└Stack 后进先出的堆栈
|　　├Set 无序,元素不可重复
|　　│├HashSet 允许包含值为null元素，最多只能一个null元素
|　　│├TreeSet 排序
|　　│└LinkedSet 
|Map 无序,元素可重复
　　├Hashtable 不允许null、同步
　　├HashMap 允许null、不同步
　　├TreeMap 
　　└WeakHashMap key实行“弱引用”，若key不再被外部引用，该key被GC回收
#### 2.2 Collection 和 Collections 有什么区别？
​        Collection 是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。

​        Collections 是一个包装类。它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，服务于Java的Collection框架。
#### 2.3 如何决定使用 HashMap 还是 TreeMap？
|Map|适用情况|原因|
|----|----|----|
|HashMap|查询|基于散列表实现（推荐作为常规Map使用）|
|TreeMap|增加、快速创建|基于红黑树实现|
#### 2.4 说一下 HashMap 的实现原理？
​        HashMap采用Entry数组来存储key-value对，每一个键值对组成了一个Entry实体，Entry类实际上是一个单向的链表结构，它具有Next指针，可以连接下一个Entry实体，以此来解决Hash冲突的问题。

​        数组存储区间是连续的，占用内存严重，故空间复杂的很大。但数组的二分查找时间复杂度小，为O(1)；数组的特点是：寻址容易，插入和删除困难；

​        链表存储区间离散，占用内存比较宽松，故空间复杂度很小，但时间复杂度很大，达O（N）。链表的特点是：寻址困难，插入和删除容易。
#### 2.5 说一下 HashSet 的实现原理？

#### 2.6 ArrayList 和 LinkedList 的区别是什么？
|List|数据结构|适用情况|原因|
|----|----|----|----|
|ArrayList|动态数组|get和set速度快|ArrayList移动数据|
|LinkedList|链表|add和remove速度快|LinkedList移动指针|
#### 2.7 如何实现数组和 List 之间的转换？
List转数组：String[] a = arrayList.toArray(new String[arrayList.size()]);
数组转List：Arrays的asList(a)方法
#### 2.8 ArrayList 和 Vector 的区别是什么？
​        Vector的方法都是同步的(Synchronized),是线程安全的(thread-safe)，而ArrayList的方法不是，由于线程的同步必然要影响性能，因此，ArrayList的性能比Vector好。 
​        当Vector或ArrayList中的元素超过它的初始大小时，Vector会将它的容量翻倍,而ArrayList只增加50%的大小，这样，ArrayList就有利于节约内存空间。
#### 2.9 Array 和 ArrayList 有何区别？
- Array是Java中的数组，声明数组有三种方式
```
int[] a=new int[10];
int a[]=new int[10];
int a[]={1,2,3,4};
可以看出：在定义一个数组的时候，必须指定这个数组的数据类型及数组的大小，也就是说数组中存放的元素个数固定并且类型一样
```
- ArrayList是动态数组,也就是数组的复杂版本，它可以动态的添加和删除元素，被称为”集合“，集合的声明如下
```
ArrayList list = new ArrayList(10);
ArrayList list1 = new ArrayList();
可以看出：在不使用泛型的情况下，这个list是可以添加进不同类型的元素的，而且arraylist是可以不用指定长度的。在使用泛型时，我们就只能添加一种类型的数据了
```
#### 2.10 在 Queue 中 poll()和 remove()有什么区别？
- queue的增加元素方法add和offer的区别在于，add方法在队列满的情况下将选择抛异常的方法来表示队列已经满了，而offer方法通过返回false表示队列已经满了；在有限队列的情况，使用offer方法优于add方法；
- remove方法和poll方法都是删除队列的头元素，remove方法在队列为空的情况下将抛异常，而poll方法将返回null；
- element和peek方法都是返回队列的头元素，但是不删除头元素，区别在与element方法在队列为空的情况下，将抛异常，而peek方法将返回null。
#### 2.11 哪些集合类是线程安全的？
- Vector
- HashTable
- StringBuffer
#### 2.12 迭代器 Iterator 是什么？
​        Iterator接口提供了很多对集合元素进行迭代的方法。每一个集合类都包括了可以返回迭代器实例的迭代方法。迭代器可以在迭代过程中删除底层集合的元素，但是不可以直接调用集合的remove(Object obj)删除，可以通过迭代器的remove()方法删除
#### 2.13 Iterator 怎么使用？有什么特点？
```
// 遍历
Iterator<String> iterator = list.iterator();
while (iterator.hasNext()) {
    String str = iterator.next();
}

// 删除元素
Iterator<String> iterator = list.iterator();
while (iterator.hasNext()) {
    String str = iterator.next();
    if ("2".equals(str)) {
    	iterator.remove();
    }
}

// forEachRemaining遍历
final Iterator<String> iterator = list.iterator();
iterator.forEachRemaining(new Consumer<String>() {
    public void accept(String t) {
    	System.out.println(t);
    }

});
```
#### 2.13 Iterator 和 ListIterator 有什么区别？
- ListIterator有add()方法，可以向List中添加对象，而Iterator不能
- ListIterator和Iterator都有hasNext()和next()方法，可以实现顺序向后遍历，但是ListIterator有hasPrevious()和previous()方法，可以实现逆向（顺序向前）遍历。Iterator就不可以。
- ListIterator可以定位当前的索引位置，nextIndex()和previousIndex()可以实现。Iterator没有此功能。
- 都可实现删除对象，但是ListIterator可以实现对象的修改，set()方法可以实现。Iierator仅能遍历，不能修改。
#### 2.14 怎么确保一个集合不能被修改？
​        我们可以采用Collections包下的unmodifiableMap方法，通过这个方法返回的map,是不可以修改的。他会报 java.lang.UnsupportedOperationException错。
​        同理：Collections包也提供了对list和set集合的方法。
Collections.unmodifiableList(List)
Collections.unmodifiableSet(Set)
### 3 多线程

#### 3.1 并行和并发有什么区别？
- 并发是指一个处理器同时处理多个任务。 
- 并行是指多个处理器或者是多核的处理器同时处理多个不同的任务。 
- 并发是逻辑上的同时发生（simultaneous），而并行是物理上的同时发生。 
 - 来个比喻：并发是一个人同时吃三个馒头，而并行是三个人同时吃三个馒头。 
#### 3.1 线程和进程的区别？
- 进程：是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统资源的基本单位。
- 线程：是进程的一个执行单元，是进程内科调度实体。比进程更小的独立运行的基本单位。线程也被称为轻量级进程。
一个程序至少一个进程，一个进程至少一个线程。
#### 3.1 守护线程是什么？
​        守护线程（即daemon thread）是个服务线程，准确地来说就是服务其他的线程，这是它的作用——而其他的线程只有一种，那就是用户线程。所以java里线程分2种，
1、守护线程，比如垃圾回收线程，就是最典型的守护线程。
2、用户线程，就是应用程序里的自定义线程。
#### 3.1 创建线程有哪几种方式？
- 继承Thread类创建线程类
 - 定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。
 - 创建Thread子类的实例，即创建了线程对象。
 - 调用线程对象的start()方法来启动该线程。
- 通过Runnable接口创建线程类
 - 定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。
 - 创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。
 - 调用线程对象的start()方法来启动该线程。
- 通过Callable和Future创建线程
 - 创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。
 - 创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。
 - 使用FutureTask对象作为Thread对象的target创建并启动新线程。
 - 调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。

```
实现Runnable、Callable接口
优点：
线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。
缺点：
编程稍微复杂，如果要访问当前线程，则必须使用Thread.currentThread()方法。
```
```
继承Thread类
优点：
编写简单，如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接使用this即可获得当前线程。
缺点：
线程类已经继承了Thread类，所以不能再继承其他父类。
```
#### 3.1 说一下 runnable 和 callable 有什么区别？
- Callable规定的方法是call()，Runnable规定的方法是run()。其中Runnable可以提交给Thread来包装下，直接启动一个线程来执行，而Callable则一般都是提交给ExecuteService来执行。 
- Callable的任务执行后可返回值，而Runnable的任务是不能返回值得 
- call方法可以抛出异常，run方法不可以 
- 运行Callable任务可以拿到一个Future对象，c表示异步计算的结果。
#### 3.1 线程有哪些状态？
![7e76cc17-0ad5-3ff3-954e-1f83463519d1](/assets/7e76cc17-0ad5-3ff3-954e-1f83463519d1.jpg)
#### 3.1 sleep() 和 wait() 有什么区别？
- sleep方法属于Thread类中的静态方法，wait属于Object的成员方法。
- sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。
- wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用（使用范围）。
#### 3.2 notify()和 notifyAll()有什么区别？
​        notifyAll使所有原来在该对象上等待被notify的所有线程统统退出wait的状态，变成等待该对象上的锁，一旦该对象被解锁，他们就会去竞争。notify则文明得多，它只是选择一个wait状态线程进行通知，并使它获得该对象上的锁，但不惊动其他同样在等待被该对象notify的线程们，当第一个线程运行完毕以后释放对象上的锁此时如果该对象没有再次使用notify语句，则即便该对象已经空闲，其他wait状态等待的线程由于没有得到该对象的通知，继续处在wait状态，直到这个对象发出一个notify或notifyAll，它们等待的是被notify或notifyAll，而不是锁。
#### 3.3 线程的 run()和 start()有什么区别？
- run()相当于线程的任务处理逻辑的入口方法，它由Java虚拟机在运行相应线程时直接调用，而不是由应用代码进行调用。
- start()的作用是启动相应的线程。启动一个线程实际是请求Java虚拟机运行相应的线程，而这个线程何时能够运行是由线程调度器决定的。
- start()调用结束并不表示相应线程已经开始运行，这个线程可能稍后运行，也可能永远也不会运行。
#### 3.4 创建线程池有哪几种方式？
Java通过Executors提供四种线程池，分别为：
- newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。
- newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。
- newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。
- newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。
#### 3.5 线程池都有哪些状态？
https://www.jianshu.com/p/4c594ee7a61e
#### 3.6 线程池中 submit()和 execute()方法有什么区别？
- submit()可以提供Future < T > 类型的返回值。executor()无返回值。
- sumbit()不会抛出异常。除非你调用Future.get()。excute()会抛出异常。
- submit入参可以为Callable，也可以为Runnable。excute入参Runnable。
#### 3.1 在 java 程序中怎么保证多线程的运行安全？
- 原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作，（atomic,synchronized）；
- 可见性：一个线程对主内存的修改可以及时地被其他线程看到，（synchronized,volatile）；
- 有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，（happens-before原则）。
#### 3.7 多线程锁的升级原理是什么？
https://blog.csdn.net/always_younger/article/details/79462684
#### 3.8 什么是死锁？
​        线程死锁是指由于两个或者多个线程互相持有对方所需要的资源，导致这些线程处于等待状态，无法前往执行。当线程进入对象的synchronized代码块时，便占有了资源，直到它退出该代码块或者调用wait方法，才释放资源，在此期间，其他线程将不能进入该代码块。当线程互相持有对方所需要的资源时，会互相等待对方释放资源，如果线程都不主动释放所占有的资源，将产生死锁。
当然死锁的产生是必须要满足一些特定条件的： 
- 互斥条件：进程对于所分配到的资源具有排它性，即一个资源只能被一个进程占用，直到被该进程释放。
- 请求和保持条件：一个进程因请求被占用资源而发生阻塞时，对已获得的资源保持不放。 
- 不剥夺条件：任何一个资源在没被该进程释放之前，任何其他进程都无法对他剥夺占用。
- 循环等待条件：当发生死锁时，所等待的进程必定会形成一个环路（类似于死循环），造成永久阻塞。
#### 3.9 怎么防止死锁？
- 加锁顺序
- 加锁时限
- 死锁检测
#### 3.10 ThreadLocal 是什么？有哪些使用场景？
https://blog.csdn.net/zzg1229059735/article/details/82715741
#### 3.11 说一下 synchronized 底层实现原理？
https://baijiahao.baidu.com/s?id=1612142459503895416&wfr=spider&for=pc
#### 3.12 synchronized 和 volatile 的区别是什么？
​        首先需要理解线程安全的两个方面：执行控制和内存可见。

​        执行控制的目的是控制代码执行（顺序）及是否可以并发执行。

​        内存可见控制的是线程执行结果在内存中对其它线程的可见性。根据Java内存模型的实现，线程在具体执行时，会先拷贝主存数据到线程本地（CPU缓存），操作完成后再把结果从线程本地刷到主存。

​        synchronized关键字解决的是执行控制的问题，它会阻止其它线程获取当前对象的监控锁，这样就使得当前对象中被synchronized关键字保护的代码块无法被其它线程访问，也就无法并发执行。更重要的是，synchronized还会创建一个内存屏障，内存屏障指令保证了所有CPU操作结果都会直接刷到主存中，从而保证了操作的内存可见性，同时也使得先获得这个锁的线程的所有操作，都happens-before于随后获得这个锁的线程的操作。

​        volatile关键字解决的是内存可见性的问题，会使得所有对volatile变量的读写都会直接刷到主存，即保证了变量的可见性。这样就能满足一些对变量可见性有要求而对读取顺序没有要求的需求。

​        使用volatile关键字仅能实现对原始变量(如boolen、 short 、int 、long等)操作的原子性，但需要特别注意， volatile不能保证复合操作的原子性，即使只是i++，实际上也是由多个原子操作组成：read i; inc; write i，假如多个线程同时执行i++，volatile只能保证他们操作的i是同一块内存，但依然可能出现写入脏数据的情况。

- volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。
- volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。
- volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性。
- volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。
- volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。
#### 3.13 synchronized 和 Lock 有什么区别？
- synchronized是java内置关键字，在jvm层面，Lock是个java类；
- synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；
- synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；
- 用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；
- synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）；
- Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。
#### 3.14 synchronized 和 ReentrantLock 区别是什么？
https://www.cnblogs.com/baxianhua/p/9370705.html
#### 3.15 说一下 atomic 的原理？
https://www.jb51.net/article/129690.htm
### 4 反射

#### 4.1 什么是反射？

#### 4.2 什么是 java 序列化？什么情况下需要序列化？

#### 4.3 动态代理是什么？有哪些应用？

#### 4.4 怎么实现动态代理？

### 5 对象拷贝

#### 5.1 为什么要使用克隆？

#### 5.2 如何实现对象克隆？

#### 5.3 深拷贝和浅拷贝区别是什么？

### 6 Java Web

#### 6.1 jsp 和 servlet 有什么区别？
- jsp经编译后就变成了Servlet。(JSP的本质就是Servlet，JVM只能识别java的类，不能识别JSP的代码，Web容器将JSP的代码编译成JVM能够识别的java类)
- jsp更擅长表现于页面显示，servlet更擅长于逻辑控制.
- Servlet中没有内置对象，Jsp中的内置对象都是必须通过HttpServletRequest对象，HttpServletResponse对象以及HttpServlet对象得到。
- Servlet的应用逻辑是在Java文件中，并且完全从表示层中的HTML里分离开来。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件。
#### 6.2 jsp 有哪些内置对象？作用分别是什么？
1、request对象：客户端请求，此请求会包含来自GET/POST请求的参数通过它才能了 解到客户的需求，然后做出响应。
2、response对象：响应客户请求的有关信息。
3、session对象：它指的是客户端与服务器的一次会话，从客户端连到服务器的一个      WebApplication开始，直到客户端与服务器断开连接为止。
4、out对象：它是JspWriter类的实例,是向客户端输出内容常用的对象。
5、page对象：它是指向当前JSP页面本身，有点象类中的this指针，它是 java.lang.Object类的实例。
6、application对象：它实现了用户间数据的共享，可存放全局变量。它开始于服务器的启动，直到服务器的关闭。
7、exception对象：它是一个例外对象，当一个页面在运行过程中发生了例外，就产生这个对象。
8、pageContext对象：它提供了对JSP页面内所有的对象及名字空间的访问。
9、config对象：它是在一个Servlet初始化时，JSP引擎向它传递信息用的。
#### 6.3 说一下 jsp 的 4 种作用域？
|名称|作用域|
|-----|-----|
|application|在所有应用程序中有效|
|session|在当前会话中有效|
|request|在当前请求中有效|
|page|在当前页面有效|
#### 6.4 session 和 cookie 有什么区别？
- COOKIE将会话数据保存在客户端且一般是经过加密处理的，而SESSION是将会话数据存在服务器。
- COOKIE保存的数据类型只能是字符串，而SESSION可以存储所有数据类型，除资源外。
- COOKIE保存的数据量较小，而SESSION保存的数据量很大。
- COOKIE数据是由服务器来生成，并传回到客户端。下次请求后，将COOKIE数据发往服务器。服务器就可以使用该COOKKIE的数据了。 
- SESSION是基于COOKIE技术的，没有COOKIE，就没有SESSION。 
- SESSION是将SESSION的ID存储COOKIE中，而SESSION的数据保存在服务器；每次向网站请求时，只需要发送SESSION的ID，通过SESSION的ID将服务器端保存的用户数据调出来。
#### 6.5 说一下 session 的工作原理？
![gni1mzjjde037](/assets/gni1mzjjde037.png)
#### 6.6 如果客户端禁止 cookie 能实现 session 还能用吗？
​        Cookie与 Session，一般认为是两个独立的东西，Session采用的是在服务器端保持状态的方案，而Cookie采用的是在客户端保持状态的方案。但为什么禁用Cookie就不能得到Session呢？因为Session是用Session ID来确定当前对话所对应的服务器Session，而Session ID是通过Cookie来传递的，禁用Cookie相当于失去了Session ID，也就得不到Session了。
#### 6.7 spring mvc 和 struts2 的区别是什么？
- 拦截机制的不同
​        Struts2是类级别的拦截，每次请求就会创建一个Action，和Spring整合时Struts2的ActionBean注入作用域是原型模式prototype，然后通过setter，getter吧request数据注入到属性。Struts2中，一个Action对应一个request，response上下文，在接收参数时，可以通过属性接收，这说明属性参数是让多个方法共享的。Struts2中Action的一个方法可以对应一个url，而其类属性却被所有方法共享，这也就无法用注解或其他方式标识其所属方法了，只能设计为多例。
​        SpringMVC是方法级别的拦截，一个方法对应一个Request上下文，所以方法直接基本上是独立的，独享request，response数据。而每个方法同时又何一个url对应，参数的传递是直接注入到方法中的，是方法所独有的。处理结果通过ModeMap返回给框架。在Spring整合时，SpringMVC的Controller Bean默认单例模式Singleton，所以默认对所有的请求，只会创建一个Controller，有应为没有共享的属性，所以是线程安全的，如果要改变默认的作用域，需要添加@Scope注解修改。
​        Struts2有自己的拦截Interceptor机制，SpringMVC这是用的是独立的Aop方式，这样导致Struts2的配置文件量还是比SpringMVC大。
  
- 底层框架的不同
​        Struts2采用Filter（StrutsPrepareAndExecuteFilter）实现，SpringMVC（DispatcherServlet）则采用Servlet实现。Filter在容器启动之后即初始化；服务停止以后坠毁，晚于Servlet。Servlet在是在调用时初始化，先于Filter调用，服务停止后销毁。
  
- 性能方面
​        Struts2是类级别的拦截，每次请求对应实例一个新的Action，需要加载所有的属性值注入，SpringMVC实现了零配置，由于SpringMVC基于方法的拦截，有加载一次单例模式bean注入。所以，SpringMVC开发效率和性能高于Struts2。

- 配置方面
​        spring MVC和Spring是无缝的。从这个项目的管理和安全上也比Struts2高。
#### 6.8 如何避免 sql 注入？
1、PreparedStatement
- 代码的可读性和可维护性。
- PreparedStatement尽最大可能提高性能。
- 最重要的一点是极大地提高了安全性。
`String sql = "select * from tb_name where name= '"+varname+"' and passwd='"+varpasswd+"'"; `
如果我们把[' or '1' = '1]作为name传入进来.密码随意,看看会成为什么? 
`select * from tb_name = 'or '1' = '1' and passwd = '随意' ; `
因为'1'='1'肯定成立,所以可以任何通过验证.更有甚者：
把`['; drop table tb_name; ]`作为varpasswd传入进来,则：
`select * from tb_name = '随意' and passwd = ''; drop table tb_name; `有些数据库是不会让你成功的，但也有很多数据库就可以使这些语句得到执行。

2、正则表达式
- 检测SQL meta-characters的正则表达式 /(\%27)|(\')|(\-\-)|(\%23)|(#)/ix
- 修正检测SQL meta-characters的正则表达式 /((\%3D)|(=))[^\n]*((\%27)|(\')|(\-\-) |(\%3B)|(:))/i
- 典型的 SQL 注入攻击的正则表达式 /\w*((\%27)|(\'))((\%6F)|o|(\%4F))((\%72)|r|(\ ))/ix
- 检测SQL注入，UNION查询关键字的正则表达式 /((\%27)|(\'))union/ix(\%27)|(\') - 单引号和它的hex等值　　union - union关键字。
- 检测MS SQL Server SQL注入攻击的正则表达式 /exec(\s|\+)+(s|x)p\w+/ix

3、字符串过滤
```
public static String filterContent(String content){
    String flt ="'|and|exec|insert|select|delete|update|count|*|%
    |chr|mid|master|truncate|char|declare|; |or|-|+|,"; 
    Stringfilter[] = flt.split("|"); 
    for(int i=0; i {
    	content.replace(filter[i], ""); 
    }
    return content; 
}
```

4、不安全字符屏蔽
​        使用JavaScript在客户端进行不安全字符屏蔽
​        检查是否含有`'、/、\\`
#### 6.9 什么是 XSS 攻击，如何避免？
​        XSS（Cross-Site Scripting）又称跨站脚本，XSS的重点不在于跨站点，而是在于脚本的执行。XSS是一种经常出现在 Web 应用程序中的计算机安全漏洞，是由于 Web 应用程序对用户的输入过滤不足而产生的，其原理是攻击者向有 XSS 漏洞的网站中输入(传入)恶意的 HTML 代码，当用 户浏览该网站时，这段 HTML 代码会自动执行，从而达到攻击的目的。常见的 XSS 攻击有三种：反射型、DOM-based 型、存储型。 其中反射型、DOM-based 型可以归类为非持久型 XSS 攻击，存储型归类为持久型 XSS 攻击。
1、XSS 输 入 通 常 包 含 JavaScript 脚 本 ， 如 弹 出 恶 意 警 告 框 ：`<script>alert(“XSS”);</script>`
2、XSS 输入也可能是 HTML 代码段，譬如：
(1) 网页不停地刷新 `<meta http-equiv=’refresh’ content=”0;”>`
(2) 嵌入其它网站的链接 构、重定向到其它网站等。
`<iframe scr=http://xxxx width=”” height=””></iframe>`

​        如何避免：
- XSS的根源主要是没完全过滤客户端提交的数据 ，所以重点是要过滤用户提交的信息。
- 将重要的cookie标记为http only, 这样的话js 中的document.cookie语句就不能获取到cookie了。
- 只允许用户输入我们期望的数据。 例如：age用户年龄只允许用户输入数字，而数字之外的字符都过滤掉。
- 对数据进行Html Encode 处理： 用户将数据提交上来的时候进行HTML编码，将相应的符号转换为实体名称再进行下一步的处理。
- 过滤或移除特殊的Html标签， 例如:`<script>，<iframe>`
- 过滤js事件的标签。例如 “onclick=”, “onfocus” 等等。

#### 6.10 什么是 CSRF 攻击，如何避免？

### 7 异常

#### 7.1 throw 和 throws 的区别？
​        throws是用来声明一个方法可能抛出的所有异常信息，throws是将异常声明但是不处理，而是将异常往上传，谁调用我就交给谁处理。而throw则是指抛出的一个具体的异常类型。
#### 7.2 final、finally、finalize 有什么区别？

#### 7.3 try-catch-finally 中哪个部分可以省略？
​        try语句后面可以省略catch语句，但是必须有finally语句。也可以省略finally语句，但是要有catch语句。
- try-catch
- try-finally
- try-catch-finally
#### 7.4 try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？
- 不管有没有异常，finally中的代码都会执行。
- 当try、catch中有return时，finally中的代码依然会继续执行。
- finally是在return后面的表达式运算之后执行的，此时并没有返回运算之后的值，而是把值保存起来，不管finally对该值做任何的改变，返回的值都不会改变，依然返回保存起来的值。也就是说方法的返回值是在finally运算之前就确定了的。
- 如果return的数据是引用数据类型，而在finally中对该引用数据类型的属性值的改变起作用，try中的return语句返回的就是在finally中改变后的该属性的值。
- finally代码中最好不要包含return，程序会提前退出，也就是说返回的值不是try或catch中的值
版权声明：本文为博主原创文章，转载请附上博文链接！
#### 7.5 常见的异常类有哪些？
​        Java标准库内建了一些通用的异常，这些类以Throwable为顶层父类。

​        Throwable又派生出Error类和Exception类。

​        错误：Error类以及他的子类的实例，代表了JVM本身的错误。错误不能被程序员通过代码处理，Error很少出现。因此，程序员应该关注Exception为父类的分支下的各种异常类。

​        异常：Exception以及他的子类，代表程序运行时发送的各种不期望发生的事件。可以被Java异常处理机制使用，是异常处理的核心。
![bf096b63f6246b6004ccb43be6f81a4c500fa2ba](/assets/bf096b63f6246b6004ccb43be6f81a4c500fa2ba.jpg)
### 8 网络

#### 8.1 http 响应码 301 和 302 代表的是什么？有什么区别？
- 301 redirect: 301 代表永久性转移(Permanently Moved)
- 302 redirect: 302 代表暂时性转移(Temporarily Moved )
​        301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（用户看到的效果就是他输入的地址A瞬间变成了另一个地址B）——这是它们的共同点。他们的不同在于。301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。
#### 8.2 forward 和 redirect 的区别？
- 从地址栏显示来说
​        forward是服务器请求资源，服务器直接访问目标地址的URL，把那个URL的响应内容读取过来，然后把这些内容再发给浏览器，浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址。
​        redirect是服务端根据逻辑,发送一个状态码，告诉浏览器重新去请求那个地址，所以地址栏显示的是新的URL，所以redirect等于客户端向服务器端发出两次request，同时也接受两次response。

- 从数据共享来说
​        forward：转发页面和转发到的页面可以共享request里面的数据。
​        redirect：不能共享数据。
​        redirect不仅可以重定向到当前应用程序的其他资源，还可以重定向到同一个站点上的其他应用程序中的资源,甚至是使用绝对URL重定向到其他站点的资源，forward方法只能在同一个Web应用程序内的资源之间转发请求，forward 是服务器内部的一种操作，redirect 是服务器通知客户端，让客户端重新发起请求，所以，你可以说 redirect是一种间接的请求，但是你不能说"一个请求是属于forward还是redirect "。

- 从运用地方来说
​        forward：一般用于用户登陆的时候,根据角色转发到相应的模块。
​        redirect：一般用于用户注销登陆时返回主页面和跳转到其它的网站等。

- 从效率来说
​        forward：高。
​        redirect：低。
#### 8.3 简述 tcp 和 udp的区别？
- TCP 是面向连接的，UDP 是面向无连接的
- UDP程序结构较简单
- TCP 是面向字节流的，UDP 是基于数据报的
- TCP 保证数据正确性，UDP 可能丢包
- TCP 保证数据顺序，UDP 不保证
#### 8.4 tcp 为什么要三次握手，两次不行吗？为什么？
https://blog.csdn.net/lengxiao1993/article/details/82771768
#### 8.5 说一下 tcp 粘包是怎么产生的？

#### 8.6 OSI 的七层模型都有哪些？
- 应用层：网络服务与最终用户的一个接口。
 - 协议有：HTTP FTP TFTP SMTP SNMP DNS TELNET HTTPS POP3 DHCP
- 表示层：数据的表示、安全、压缩。（在五层模型里面已经合并到了应用层）
 - 格式有：JPEG、ASCll、DECOIC、加密格式等
- 会话层：建立、管理、终止会话。（在五层模型里面已经合并到了应用层），对应主机进程，指本地主机与远程主机正在进行的会话
- 传输层：定义传输数据的协议端口号，以及流控和差错校验。
 - 协议有：TCP UDP，数据包一旦离开网卡即进入网络传输层
- 网络层：进行逻辑地址寻址，实现不同网络之间的路径选择。
 - 协议有：ICMP IGMP IP（IPV4 IPV6） ARP RARP
- 数据链路层：建立逻辑连接、进行硬件地址寻址、差错校验 [2]  等功能。（由底层网络定义协议），将比特组合成字节进而组合成帧，用MAC地址访问介质，错误发现但不能纠正。
- 物理层：建立、维护、断开物理连接。（由底层网络定义协议）
#### 8.7 get 和 post 请求有哪些区别？
区别：
- GET请求的参数是放在URL里的，POST请求参数是放在请求body里的；
- GET请求的URL传参有长度限制，而POST请求没有长度限制；
- GET请求的参数只能是ASCII码，所以中文需要URL编码，而POST请求传参没有这个限制；
#### 8.8 如何实现跨域？

#### 8.9 说一下 JSONP 实现原理？

### 9 设计模式

#### 9.1 说一下你熟悉的设计模式？

#### 9.2 简单工厂和抽象工厂有什么区别？

### 10 Spring/Spring MVC

#### 10.1 为什么要使用 spring？
​        Spring是轻量级的IoC和AOP的容器框架，主要是针对javaBean的生命周期进行管理的轻量级容器，一般在传统的Java开发中具有高度的耦合性，一个项目中或者一个逻辑功能的实现时，往往一个对象需要依赖很多的对象来完成自己的操作，这样就造成了两个类的依赖关系太强，改一个地方，往往牵扯很多类牵扯大量的代码。 

​        Spring可以管理对象和对象之间的依赖关系，我们不需要自己建立对象，把这部分工作全部转交给容器完成，具有低耦合，对代码没有侵略性，对服务器没有依赖性特点的框架。
#### 10.2 解释一下什么是 aop？
​        AOP是Spring提供的关键特性之一。AOP即面向切面编程，是OOP编程的有效补充。使用AOP技术，可以将一些系统性相关的编程工作，独立提取出来，独立实现，然后通过切面切入进系统。从而避免了在业务逻辑的代码中混入很多的系统相关的逻辑——比如权限管理，事物管理，日志记录等等。

​       AOP相关的概念
- Aspect ：切面，切入系统的一个切面。比如事务管理是一个切面，权限管理也是一个切面；
- Join point ：连接点，也就是可以进行横向切入的位置；
- Advice ：通知，切面在某个连接点执行的操作(分为: Before advice , After returning advice , After throwing advice , After (finally) advice , Around advice )；
- Pointcut ：切点，符合切点表达式的连接点，也就是真正被切入的地方；

​      AOP 的实现原理
​      AOP分为静态AOP和动态AOP。静态AOP是指AspectJ实现的AOP，他是将切面代码直接编译到Java类文件中。动态AOP是指将切面代码进行动态织入实现的AOP。

​      Spring的AOP为动态AOP，实现的技术为： JDK提供的动态代理技术 和 CGLIB(动态字节码增强技术) 。尽管实现技术不一样，但 都是基于代理模式 ， 都是生成一个代理对象 。
#### 10.3 解释一下什么是 ioc？
​        在Spring之中，始终最为重要的两个思想就是 控制反转IOC和依赖注入DI。没有IoC的程序中我们使用面向对象编程对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。

​        java程序中的每个业务逻辑至少需要两个或以上的对象来协作完成，通常，每个对象在使用他的合作对象时，自己均要使用像new object（） 这样的语法来完成合作对象的申请工作。你会发现：对象间的耦合度高了。而IOC的思想是：Spring容器来实现这些相互依赖对象的创建、协调工作。对象只需要关系业务逻辑本身就可以了。从这方面来说，对象如何得到他的协作对象的责任被反转了（IOC、DI）

​        那么IoC是如何做的呢？有点像通过婚介找女朋友，在我和女朋友之间引入了一个第三者：婚姻介绍所。婚介管理了很多男男女女的资料，我可以向婚介提出一个列表，告诉它我想找个什么样的女朋友，比如长得像李嘉欣，身材像林熙雷，唱歌像周杰伦，速度像卡洛斯，技术像齐达内之类的，然后婚介就会按照我们的要求，提供一个mm，我们只需要去和她谈恋爱、结婚就行了。简单明了，如果婚介给我们的人选不符合要求，我们就会抛出异常。整个过程不再由我自己控制，而是有婚介这样一个类似容器的机构来控制。Spring所倡导的开发方式就是如此，所有的类都会在spring容器中登记，告诉spring你是个什么东西，你需要什么东西，然后spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由 spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。

​        IoC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的。比如对象A需要操作数据库，以前我们总是要在A中自己编写代码来获得一个Connection对象，有了 spring我们就只需要告诉spring，A中需要一个Connection，至于这个Connection怎么构造，何时构造，A不需要知道。在系统运行时，spring会在适当的时候制造一个Connection，然后像打针一样，注射到A当中，这样就完成了对各个对象之间关系的控制。A需要依赖 Connection才能正常运行，而这个Connection是由spring注入到A中的，依赖注入的名字就这么来的。 

​        那么DI是如何实现的呢？ 反射实现（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的。
#### 10.4 spring 有哪些主要模块？

#### 10.5 spring 常用的注入方式有哪些？
- 构造方法注入
- set方法参数注入
- 接口注入
#### 10.6 spring 中的 bean 是线程安全的吗？

#### 10.7 spring 支持几种 bean 的作用域？

#### 10.8 spring 自动装配 bean 有哪些方式？

#### 10.9 spring 事务实现方式有哪些？
- aspectJ AOP实现事务
- 事务代理工厂Bean实现事务
- 注解方式实现事务
#### 10.10 说一下 spring 的事务隔离？
https://blog.csdn.net/weixin_38070406/article/details/78157603
https://yq.aliyun.com/articles/48893
#### 10.11 说一下 spring mvc 运行流程？
https://www.cnblogs.com/glorywzm/p/6503141.html
#### 10.12 spring mvc 有哪些组件？
https://blog.csdn.net/qq_36827957/article/details/82964346
#### 10.13 @RequestMapping 的作用是什么？
​        @RequestMapping是一个用来处理请求地址映射的注解，可用于类或者方法上。

​        用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。

#### 10.14 @Autowired 的作用是什么？
​        @Autowired可以对成员变量、方法和构造函数进行标注，来完成自动装配的工作，@Autowired是根据类型进行自动装配的，如果需要按名称进行装配，则需要配合@Qualifier使用；

​        @Autowired标注可以放在成员变量上，也可以放在成员变量的set方法上。前者，Spring会直接将UserDao类型的唯一一个bean赋值给userDao这个成员变量；后者，Spring会调用setUserDao方法来将UserDao类型的唯一一个bean装配到userDao这个属性。

​        Spring 2.5 引入了@Autowired注释，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。通过@Autowired的使用来消除set，get方法。

### 11 Spring Boot/Spring Cloud

#### 11.1 什么是 spring boot？
​        在Spring框架这个大家族中，产生了很多衍生框架，比如 Spring、SpringMvc框架等，Spring的核心内容在于控制反转(IOC)和依赖注入(DI),所谓控制反转并非是一种技术，而是一种思想，在操作方面是指在spring配置文件中创建`<bean>`，依赖注入即为由spring容器为应用程序的某个对象提供资源，比如 引用对象、常量数据等。

​        SpringBoot是一个框架，一种全新的编程规范，他的产生简化了框架的使用，所谓简化是指简化了Spring众多框架中所需的大量且繁琐的配置文件，所以 SpringBoot是一个服务于框架的框架，服务范围是简化配置文件。

#### 11.2 为什么要用 spring boot？
​        最明显的特点是，让文件配置变的相当简单、让应用部署变的简单（SpringBoot内置服务器，并装备启动类代码），可以快速开启一个Web容器进行开发。

#### 11.3 spring boot 核心配置文件是什么？
`bootstrap (.yml 或者 .properties)`
`application (.yml 或者 .properties)`
​        对比 application 配置文件，bootstrap 配置文件具有以下几个特性：
 - boostrap 由父 ApplicationContext 加载，比 applicaton 优先加载
 - boostrap 里面的属性不能被覆盖
 - bootstrap/ application 的应用场景
 - application 配置文件这个容易理解，主要用于 Spring Boot 项目的自动化配置。
​        bootstrap 配置文件有以下几个应用场景：
 - 使用 Spring Cloud Config 配置中心时，这时需要在 bootstrap 配置文件中添加连接到配置中心的配置属性来加载外部配置中心的配置信息；
 - 一些固定的不能被覆盖的属性
 - 一些加密/解密的场景；
#### 11.4 spring boot 配置文件有哪几种类型？它们有什么区别？

#### 11.5 spring boot 有哪些方式可以实现热部署？

#### 11.6 jpa 和 hibernate 有什么区别？
​        JPA 仅仅是个规范。它描述了客户端操作使用的接口和标准的对象关系映射元数据（java annotations注解或者XML描述符）。在API定义之上，JPA也解释了（尽管不是很详尽）这些规范应当怎样去实现。JPA演化成 JAVA EE平台（JAVA EE6 JPA2.0，JAVAEE7 介绍了JPA2.1）

​        Hibernate原本在JPA规范首次发布的时候就是一个全功能的Java ORM实现。尽管它实现了JPA规范，但是也保留了原生的native api，以保证可以向后兼容和兼容一些非标准的特性。

​        尽管遵循JPA规范是最好的，在实际中，很多JPA的实现都提供额外的高性能的数据处理层的特性。为了这个，Hibernate提供了以下几个规范中没有规定的特性：
- 继承的主键生成（hi.io,pooled,pooled-lo）
- 透明的prepared statement处理
- 自定义的CRUD(@SQLInsert,@SQLUpdate,@SQLDelete)语句
- 静态/动态的实体集合过滤（如@FilterDef,@Filter,@Where）
- 映射属性到SQL片段（如@Forum）
- 不可改变的实体（如@Immutable）
- 更多的flush模式如（FlushMode.MANUAL,FlushMode.ALWAYS）
- 通过给定实体的主键二级缓存
- 实体-级别的并发缓存（如Cache(usage=CacheConcurrencyStrategy.READ_WRITE)）
- 通过HQL的大量版本更新
- 乐观锁的字段检查排除（如@OptimisticLock(excluded=true)）
- 去版本的乐观锁（如OptimisticLockType.ALL,OptimisticLockType.DIRTY）
- 支持跳过悲观锁的请求（无等待）
- 支持java8Date和Time及stream()
- 支持多重任务处理
#### 11.7 什么是 spring cloud？
​        Spring Cloud 就是致力于分布式系统、云服务的框架。Spring Cloud 为开发人员提供了快速构建分布式系统中一些常见模式的工具，例如：配置管理、服务注册与发现、断路器、智能路由、服务间调用、负载均衡、微代理、控制总线、一次性令牌、全局锁、领导选举、分布式会话、集群状态、分布式消息等，使用 Spring Cloud 开发人员可以开箱即用的实现这些模式的服务和应用程序。这些服务可以任何环境下运行，包括分布式环境，也包括开发人员自己的笔记本电脑以及各种托管平台。
#### 11.8 spring cloud 断路器的作用是什么？

#### 11.9 spring cloud 的核心组件有哪些？

### 12 Hibernate

#### 12.1 为什么要使用 hibernate？

#### 12.2 什么是 ORM 框架？

#### 12.3 hibernate 中如何在控制台查看打印的 sql 语句？

#### 12.4 hibernate 有几种查询方式？

#### 12.5 hibernate 实体类可以被定义为 final 吗？

#### 12.6 在 hibernate 中使用 Integer 和 int 做映射有什么区别？

#### 12.7 hibernate 是如何工作的？

#### 12.8 get()和 load()的区别？

#### 12.9 说一下 hibernate 的缓存机制？

#### 12.10 hibernate 对象有哪些状态？

#### 12.11 在 hibernate 中 getCurrentSession 和 openSession 的区别是什么？

#### 12.12 hibernate 实体类必须要有无参构造函数吗？为什么？

### 13 Mybatis

#### 13.1 mybatis 中 #{}和 ${}的区别是什么？
- #{} 占位符；${} 拼接符。
- #{} 为参数占位符 ?，即sql 预编译；${} 为字符串替换，即 sql 拼接。
- #{}：动态解析 -> 预编译 -> 执行；${}：动态解析 -> 编译 -> 执行。
- #{} 的变量替换是在DBMS 中；${} 的变量替换是在 DBMS 外。
- 变量替换后，#{} 对应的变量自动加上单引号''；变量替换后，${} 对应的变量不会加上单引号''。
- #{} 能防止sql 注入；${} 不能防止sql 注入。
#### 13.2 mybatis 有几种分页方式？

#### 13.3 RowBounds 是一次性查询全部结果吗？为什么？
Mysql中可以使用limit语句，但limit并不是标准SQL中的，如果是其它的数据库，则需要使用其它语句。MyBatis提供了RowBounds类，用于实现分页查询。RowBounds中有两个数字，offset和limit。
#### 13.4 mybatis 逻辑分页和物理分页的区别是什么？
- 使用RowBounds对象进行逻辑（逻辑内存中）分页，它是针对ResultSet结果集执行的内存分页。
- 使用pageHelper插件进行物理分页（其实是依赖物理数据库实体）。
![7e76cc17-0ad5-3ff3-954e-1f83463519d1](/assets/微信截图_20190620102938.png)
#### 13.5 mybatis 是否支持延迟加载？延迟加载的原理是什么？

#### 13.6 说一下 mybatis 的一级缓存和二级缓存？

#### 13.7 mybatis 和 hibernate 的区别有哪些？
- Mybatis轻量级封装jdbc；hibernate是重量级封装jdbc。
- mybatis开发效率慢，运行效率快；  hibernate开发效率快，运行效率慢。
- mybatis使用的是sql； hibernate使用的是hql。
- mybatis需要程序员对sql熟练掌握； hibernate使用起来方便，对程序要得sql没要过多的要求。
- mybatis更加灵活；hibernate如果碰见复杂的查询，不是很灵活。
#### 13.8 mybatis 有哪些执行器（Executor）？

#### 13.9 mybatis 分页插件的实现原理是什么？

#### 13.10 mybatis 如何编写一个自定义插件？

### 14 RabbitMQ

#### 14.1 rabbitmq 的使用场景有哪些？

#### 14.2 rabbitmq 有哪些重要的角色？

#### 14.3 rabbitmq 有哪些重要的组件？

#### 14.4 rabbitmq 中 vhost 的作用是什么？

#### 14.5 rabbitmq 的消息是怎么发送的？

#### 14.6 rabbitmq 怎么保证消息的稳定性？

#### 14.7 rabbitmq 怎么避免消息丢失？

#### 14.8 要保证消息持久化成功的条件有哪些？

#### 14.9 rabbitmq 持久化有什么缺点？

#### 14.10 rabbitmq 有几种广播类型？

#### 14.11 rabbitmq 怎么实现延迟消息队列？

#### 14.12 rabbitmq 集群有什么用？

#### 14.13 rabbitmq 节点的类型有哪些？

#### 14.14 rabbitmq 集群搭建需要注意哪些问题？

#### 14.15 rabbitmq 每个节点是其他节点的完整拷贝吗？为什么？

#### 14.16 rabbitmq 集群中唯一一个磁盘节点崩溃了会发生什么情况？

#### 14.17 rabbitmq 对集群节点停止顺序有要求吗？

### 15 Kafka

#### 15.1 kafka 可以脱离 zookeeper 单独使用吗？为什么？

#### 15.2 kafka 有几种数据保留的策略？

#### 15.3 kafka 同时设置了 7 天和 10G 清除数据，到第五天的时候消息达到了 10G，这个时候 kafka 将如何处理？

#### 15.4 什么情况会导致 kafka 运行变慢？

#### 15.5 使用 kafka 集群需要注意什么？

### 16 Zookeeper

#### 16.1 zookeeper 是什么？

#### 16.2 zookeeper 都有哪些功能？

#### 16.3 zookeeper 有几种部署模式？

#### 16.4 zookeeper 怎么保证主从节点的状态同步？

#### 16.5 集群中为什么要有主节点？

#### 16.6 集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？

#### 16.7 说一下 zookeeper 的通知机制？

### 17 MySql

#### 17.1 数据库的三范式是什么？
​        第一范式：当关系模式R的所有属性都不能在分解为更基本的数据单位时，称R是满足第一范式的，简记为1NF。满足第一范式是关系模式规范化的最低要求，否则，将有很多基本操作在这样的关系模式中实现不了。

​        第二范式：如果关系模式R满足第一范式，并且R得所有非主属性都完全依赖于R的每一个候选关键属性，称R满足第二范式，简记为2NF。

​        第三范式：设R是一个满足第一范式条件的关系模式，X是R的任意属性集，如果X非传递依赖于R的任意一个候选关键字，称R满足第三范式，简记为3NF.
#### 17.2 一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 mysql 数据库，又插入了一条数据，此时 id 是几？
9
#### 17.3 如何获取当前数据库版本？
`select version();`
`mysql -V`
#### 17.4 说一下 ACID 是什么？
- Atomicity 原子性
原子性，指的是整个事务是一个独立的单元，要么操作成功，要么操作不成功
- Consistency 一致性
一致性，事务必须要保持和系统处于一致的状态（如果不一致会导致系统其它的方出现bug）
- Isolation 隔离性
隔离性，事务是并发控制机制，他们的交错也需要一致性，隔离隐藏，一般通过悲观或者乐观锁实现
- Durability 耐久性
耐久性，一个成功的事务将永久性地改变系统的状态，所以在它结束之前，所有导致状态的变化都记录在一个持久的事务日志中
#### 17.5 char 和 varchar 的区别是什么？
- char的长度是不可变的，而varchar的长度是可变的，
- 定义一个char[10]和varchar[10],如果存进去的是‘abcd’,那么char所占的长度依然为10，除了字符‘abcd’外，后面跟六个空格，而varchar就立马把长度变为4了，取数据的时候，char类型的要用trim()去掉多余的空格，而varchar是不需要的.
- char的存取速度要比varchar要快得多，因为其长度固定，方便程序的存储与查找；但是char也为此付出的是空间的代价，因为其长度固定，所以难免会有多余的空格占位符占据空间，可谓是以空间换取时间效率，而varchar是以空间效率为首位的。
- char的存储方式是，对英文字符（ASCII）占用1个字节，对一个汉字占用两个字节；而varchar的存储方式是，对每个英文字符占用2个字节，汉字也占用2个字节，两者的存储数据都非unicode的字符数据。
#### 17.6 float 和 double 的区别是什么？
https://www.cnblogs.com/gulibao/p/5416245.html
#### 17.7 mysql 的内连接、左连接、右连接有什么区别？
​        内连接关键字：inner join；左连接：left join；右连接：right join。 内连接是把匹配的关联数据显示出来；左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反
#### 17.8 mysql 索引是怎么实现的？
​        索引是满足某种特定查找算法的数据结构，而这些数据结构会以某种方式指向数据，从而实现高效查找数据。 具体来说 MySQL 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 B+ 树实现的，B+ 树的搜索效率，可以到达二分法的性能，找到数据区域之后就找到了完整的数据结构了，所有索引的性能也是更好的
#### 17.9 怎么验证 mysql 的索引是否满足需求？
​        使用 explain 查看 SQL 是如何执行查询语句的，从而分析你的索引是否满足需求。
explain 语法：
`explain select * from table where type=1`
#### 17.10 说一下数据库的事务隔离？
​        MySQL 的事务隔离是在 MySQL.ini 配置文件里添加的，在文件的最后添加：
`transaction-isolation = REPEATABLE-READ`

​        可用的配置值：READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE。
- READ-UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。
- READ-COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。
- REPEATABLE-READ：可重复读，默认级别，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读）。
- SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。

​        脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。

​        不可重复读 ：是指在一个事务内，多次读同一数据。

​        幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。

#### 17.11 说一下 mysql 常用的引擎？
​        InnoDB 引擎：InnoDB 引擎提供了对数据库 acid 事务的支持，并且还提供了行级锁和外键的约束，它的设计的目标就是处理大数据容量的数据库系统。MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎是不支持全文搜索，同时启动也比较的慢，它是不会保存表的行数的，所以当进行`select count(*) from table`指令的时候，需要进行扫描全表。由于锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率。

​        MyIASM 引擎：MySQL 的默认引擎，但不提供事务的支持，也不支持行级锁和外键。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和 InnoDB 不同的是，MyIASM 引擎是保存了表的行数，于是当进行`select count(*) from table`语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。
#### 17.12 说一下 mysql 的行锁和表锁？
MyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。
表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。
行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。
#### 17.13 说一下乐观锁和悲观锁？
​        乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。

​        悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。

​        数据库的乐观锁需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。
#### 17.14 mysql 问题排查都有哪些手段？
- 使用 show processlist 命令查看当前所有连接信息
- 使用 explain 命令查询 SQL 语句执行计划
- 开启慢查询日志，查看慢查询的 SQL
#### 17.15 如何做 mysql 的性能优化？
- 为搜索字段创建索引
- 避免使用`select *`，列出需要查询的字段
- 垂直分割分表
- 选择正确的存储引擎
### 18 Redis

#### 18.1 redis 是什么？都有哪些使用场景？

#### 18.2 redis 有哪些功能？

#### 18.3 redis 和 memecache 有什么区别？

#### 18.4 redis 为什么是单线程的？

#### 18.5 什么是缓存穿透？怎么解决？

#### 18.6 redis 支持的数据类型有哪些？

#### 18.7 redis 支持的 java 客户端都有哪些？

#### 18.8 jedis 和 redisson 有哪些区别？

#### 18.9 怎么保证缓存和数据库数据的一致性？

#### 18.10 redis 持久化有几种方式？

#### 18.11 redis 怎么实现分布式锁？

#### 18.12 redis 分布式锁有什么缺陷？

#### 18.13 redis 如何做内存优化？

#### 18.14 redis 淘汰策略有哪些？

#### 18.15 redis 常见的性能问题有哪些？该如何解决？

### 19 JVM

#### 19.1 说一下 jvm 的主要组成部分？及其作用？
![7e76cc17-0ad5-3ff3-954e-1f83463519d1](/assets/994276-20161218141127183-1877010567.png)
​        类加载子系统：负责从文件系统或者网络中加载Class信息，加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中可能还会存放运行时常量池信息，包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）。

​        java堆：在虚拟机启动的时候建立，它是java程序最主要的内存工作区域。几乎所有的java对象实例都存放在java堆中。堆空间是所有线程共享的，这是一块与java应用密切相关的内存空间。

​        java的NIO库允许java程序使用直接内存。直接内存是在java堆外的、直接向系统申请的内存空间。通常访问直接内存的速度会优于java堆。因此出于性能的考虑，读写频繁的场合可能会考虑使用直接内存。由于直接内存在java堆外，因此它的大小不会直接受限于Xmx指定的最大堆大小，但是系统内存是有限的，java堆和直接内存的总和依然受限于操作系统能给出的最大内存。

​        垃圾回收系统：是java虚拟机的重要组成部分，垃圾回收器可以对方法区、java堆和直接内存进行回收。其中，java堆是垃圾收集器的工作重点。和C/C++不同，java中所有的对象空间释放都是隐式的，也就是说，java中没有类似free()或者delete()这样的函数释放指定的内存区域。对于不再使用的垃圾对象，垃圾回收系统会在后台默默工作，默默查找、标识并释放垃圾对象，完成包括java堆、方法区和直接内存中的全自动化管理。

​        java栈：每一个java虚拟机线程都有一个私有的java栈，一个线程的java栈在线程创建的时候被创建，java栈中保存着帧信息，java栈中保存着局部变量、方法参数，同时和java方法的调用、返回密切相关。

​        本地方法栈：和java栈非常类似，最大的不同在于java栈用于方法的调用，而本地方法栈则用于本地方法的调用，作为对java虚拟机的重要扩展，java虚拟机允许java直接调用本地方法（通常使用C编写）

​        PC（Program Counter）寄存器：也是每一个线程私有的空间，java虚拟机会为每一个java线程创建PC寄存器。在任意时刻，一个java线程总是在执行一个方法，这个正在被执行的方法称为当前方法。如果当前方法不是本地方法，PC寄存器就会指向当前正在被执行的指令。如果当前方法是本地方法，那么PC寄存器的值就是undefined

#### 19.2 说一下 jvm 运行时数据区？

#### 19.3 说一下 jvm 运行时数据区？
​        不同虚拟机的运行时数据区可能略微有所不同，但都会遵从 Java 虚拟机规范， Java 虚拟机规范规定的区域分为以下 5 个部分：
​        程序计数器（Program Counter Register）：当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成。
​        Java 虚拟机栈（Java Virtual Machine Stacks）：用于存储局部变量表、操作数栈、动态链接、方法出口等信息。
​        本地方法栈（Native Method Stack）：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的。
​        Java 堆（Java Heap）：Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存。
​        方法区（Methed Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。

#### 19.4 说一下堆栈的区别？
​        栈内存：栈内存首先是一片内存区域，存储的都是局部变量，凡是定义在方法中的都是局部变量（方法外的是全局变量），for循环内部定义的也是局部变量，是先加载函数才能进行局部变量的定义，所以方法先进栈，然后再定义变量，变量有自己的作用域，一旦离开作用域，变量就会被释放。栈内存的更新速度很快，因为局部变量的生命周期都很短。

​        堆内存：存储的是数组和对象（其实数组就是对象），凡是new建立的都是在堆中(这句话还是不严谨，JVM中的逃逸分析就打破了这一点，详情请看链接:https://mp.csdn.net/postedit/81214178)，堆中存放的都是实体（对象），实体用于封装数据，而且是封装多个（实体的多个属性），如果一个数据消失，这个实体也没有消失，还可以用，所以堆是不会随时释放的，但是栈不一样，栈里存放的都是单个变量，变量被释放了，那就没有了。堆里的实体虽然不会被释放，但是会被当成垃圾，Java有垃圾回收机制不定时的收取。

- 功能方面：堆是用来存放对象的，栈是用来执行程序的
- 共享性：堆是线程共享的，栈是线程私有的
- 空间大小：堆大小远远大于栈
#### 19.5 队列和栈是什么？有什么区别？
- 队列和栈都是被用来预存储数据的。
- 队列允许先进先出检索元素，但也有例外的情况，Deque 接口允许从两端检索元素。
- 栈和队列很相似，但它运行对元素进行后进先出进行检索
#### 19.6 什么是双亲委派模型？
​        在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。

类加载器分类
​        启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载Java_HOME/lib/目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库。
其他类加载器
​        扩展类加载器（Extension ClassLoader）：负责加载\lib\ext目录或Java. ext. dirs系统变量指定的路径中的所有类库。
​        应用程序类加载器（Application ClassLoader）：负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。

​        双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。
#### 19.7 说一下类加载的执行过程？
类装载分为以下 5 个步骤：
- 加载：根据查找路径找到相应的 class 文件然后导入。
- 检查：检查加载的 class 文件的正确性。
- 准备：给类中的静态变量分配内存空间。
- 解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址。
- 初始化：对静态变量和静态代码块执行初始化工作。
#### 19.8 怎么判断对象是否可以被回收？
一般有两种方法来判断：
- 引用计数器：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题。
- 可达性分析：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。
#### 19.9 java 中都有哪些引用类型？
- 强引用：发生 gc 的时候不会被回收。
- 软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。
- 弱引用：有用但不是必须的对象，在下一次GC时会被回收。
- 虚引用（幽灵引用/幻影引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知。
#### 19.10 说一下 jvm 有哪些垃圾回收算法？
- 标记-清除算法：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。
- 标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。
- 复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半。
- 分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。
#### 19.11 说一下 jvm 有哪些垃圾回收器？
- Serial：最早的单线程串行垃圾回收器。
- Serial Old：Serial 垃圾回收器的老年版本，同样也是单线程的，可以作为 CMS 垃圾回收器的备选预案
- ParNew：是 Serial 的多线程版本。
- Parallel 和 ParNew 收集器类似是多线程的，但 Parallel 是吞吐量优先的收集器，可以牺牲等待时间换取系统的吞吐量。
- Parallel Old 是 Parallel 老生代版本，Parallel 使用的是复制的内存回收算法，Parallel Old 使用的是标记-整理的内存回收算法。
- CMS：一种以获得最短停顿时间为目标的收集器，非常适用 B/S 系统。
- G1：一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项。
#### 19.12 详细介绍一下 CMS 垃圾回收器？
​        CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上`-XX:+UseConcMarkSweepGC`来指定使用 CMS 垃圾回收器。

​        CMS 使用的是标记-清除的算法实现的，所以在 gc 的时候回产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。
#### 19.13 新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？
- 新生代回收器：Serial、ParNew、Parallel Scavenge
- 老年代回收器：Serial Old、Parallel Old、CMS
- 整堆回收器：G1

​        新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；老年代回收器一般采用的是标记-整理的算法进行垃圾回收。
#### 19.14 简述分代垃圾回收器是怎么工作的？
​        分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。

​        新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：
1、把 Eden + From Survivor 存活的对象放入 To Survivor 区。
2、清空 Eden 和 From Survivor 分区。
3、From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。

​        每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。 老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。
#### 19.15 说一下 jvm 调优的工具？
​        JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。

- jconsole：用于对 JVM 中的内存、线程和类等进行监控；
- jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等
#### 19.16 常用的 jvm 调优的参数都有哪些？
```
-Xms2g：初始化推大小为 2g
-Xmx2g：堆最大内存为 2g
-XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4
-XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2
–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合
-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合
-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合
-XX:+PrintGC：开启打印 gc 信息
-XX:+PrintGCDetails：打印 gc 详细信息
```